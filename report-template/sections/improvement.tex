错误恢复机制 ：本项目的词法分析器在遇到非法字符或错误时，会跳过当前行的剩余部分并返回错误。这是一种简单的恐慌模式错误恢复策略，即在检测到错误后，跳过一部分输入直到找到一个看似可以继续解析的同步点。可以设计更加用户友好的错误报告，比如“在 X 处期望得到 Y，但找到了 Z”，并给出可能的修正建议。还比如不仅仅跳到行尾，而是跳到更合适的同步词法单元，例如语句结束符 ;、块的开始/结束符号 (begin, end) 或文件末尾。这需要在文法中定义哪些词法单元可以作为同步点。

目前，对于变量声明的情况，无法维护其所属的过程名。在支持嵌套函数或过程的语言中，一个变量的完全限定名或用于查找作用域链的信息通常需要包含其所在的函数/过程信息。 在解析函数体或任何可能包含变量声明的块时，可以将当前正在解析的函数/过程的名称作为参数传递给其他方法，限于时间有限无法完成。

在文法中没有区分实参和形参，导致进一步语义分析可能出现了意料不到的错误。函数定义时的参数列表（形参）应该在函数体的局部作用域内进行声明，并且这些形参应该在函数体内部可见。这可能需要修改文法来明确区分函数定义和函数调用，并为函数定义引入形参列表的文法规则，例如 <形参列表> → <变量> { , <变量> } | ε

我们只对文件流进行了简化实现，在prep.rs 中的文件不足可能在于错误处理比较简单，以及没有考虑字符编码问题。lex.rs 和 parse.rs 中的文件错误输出每次都会新建并覆盖文件，没有追加功能。而且错误应该输出到标准错误流而不是标准输出，这在命令行工具中是更好的实践。应该采用更安全的IO方式；

lex.rs 中的 current_token 方法是手写的状态转换逻辑，模拟了有限自动机。
手写 DFA 对于简单文法是可行的,但对于复杂语言，状态和转换会变得非常多且难以管理，容易出错。之后可以尝试手动实现一个表驱动的 DFA，根据当前状态和输入字符查找下一个状态。

输入优化：Lexer 在 getchar 中使用下标索引的来获取字符。这种方式在 pos 较大时效率较低，因为它需要从字符串的开头开始遍历字符直到 pos 位置.更好的方式是使用 
缓冲读取，对于非常大的文件，可以考虑实现或使用带缓冲的文件读取，而不是一次性将整个文件读入内存。
